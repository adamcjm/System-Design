
[高可用架构设计之无状态服务](https://developer.51cto.com/art/202103/649115.htm)|
---|

* [高可用架构理论](#高可用架构理论)
  * [CAP定理](#CAP定理)---从理论上论证了存储高可用的复杂度。数据一致性相关的理论
    * [Consistency](#Consistency)(一致性)
    * [Availability](#Availability)(可用性)
    * [Partition Tolerance](#Partition-Tolerance)(分区容错性)
  * [ACID定理](#ACID定理)---数据一致性相关的理论
  * [BASE定理](#BASE定理)---数据一致性相关的理论
  * [FMEA分析方法](#FMEA分析方法)---高可用架构的分析方法
  * 可用性的度量
* 高可用架构  
* 业务高可用---高可用的应用
  * 异地多活
  * 接口级的故障应对方案
    * 降级
    * 熔断
    * 限流
    * 排队
* [存储高可用](#存储高可用)---高可用的数据
  * [主备复制](#主备复制)
  * [主从复制](#主从复制)
  * [主主复制](#主主复制)
  * [主备倒换与主从倒换](#主备倒换与主从倒换)
  * [数据集群](#数据集群)
    * [数据集中集群](#数据集中集群)
    * [数据分布集群](#数据分布集群)
    * 分布式事务算法
    * 分布式一致性算法
  * 数据分区
* 计算高可用---高可用的服务
  * 计算高可用复杂度
  * 高可用双机调度算法
  * 主主  
  * 主备
    * 热备
    * 温备
    * 冷备
  * 主从
  * 对称集群
  * 非对称集群





 --- 
# 高可用架构理论
  
    ACID 是数据库事务完整性的理论， CAP 是分布式系统设计理论， BASE是CAP 理论中AP 方案的延伸。

## CAP定理
      
      对于设计分布式系统的架构师来说， CAP 是必须掌握的理论。
      
      CAP 理论告诉我们分布式系统只能选择CP 或AP ，但其实这里的前提是系统发生了“分区”
      
      虽然CAP 理论定义是三个要素中只能取两个，但放到分布式环境下来思考，我们必须要首先考虑系统是否会发生了“分区”现象（节点间的网络连接一切正常），也
      就是说CAP中P是重点，有两种情况：
      
      1. 没有分区现象
         如果系统没有发生分区现象，也就是说P 不存在的时候（节点间的网络连接一切正常），我们没有必要放弃C 或A，应该C 和A 都可以保证，这就要求架构
         设计的时候既要考虑分区发生时选择CP 还是AP ，也要考虑分区没有发生时如何保证CA 。

      2. 有分区现象
      
         因为网络本身无法做到100%可靠，有可能出故障，所以分区是一个必然的现象。如果我们选择了CA 而放弃了P，那么当发生分区现象时，为了保证C ，系统需
         要禁止写入，当有写入请求时，系统返回 error （例如，当前系统不允许写入），这又和A 冲突了，因为A 要求返回no eηor 和no timeout。因此，分布式
         系统理论上不可能选择CA 架构，只能选择CP 或AP 架构。
      
      
      前后有两版的CAP定理：
      
      第一版：
      
          any distibuted system cannot guaranty C, A, and P simu ltaneously 。
          简单翻译为： 对于一个分布式计算系统，不可能同时满足一致性（ Consistence ）、可用性(Availability ）、分区容错性（ 
          Partition Tolerance ）三个设计约束。
          
      第二版：
     
          in a distibuted system (a collection of inteconnected nodes that shae data.), you can only have
          two out of the following thee guaantees acoss a wite/read pai： Co1sistency, Availability, and
          Patition Toleance - one of them must be sacrificed 。

          简单翻译为：在一个分布式系统（ 指互相连接并共享数据的节点的集合）中，当涉及读写操作时，只能保证一致性（ Consistence ）、可用性
          （ Availability ）、分区容错性（ Partition Tolerance)三者中的两个，另外一个必须被牺牲。     
          
      前后有两版的差异点：
      
           (1）第二版定义了什么才是CAP 理论探讨的分布式系统，强调了两点： interconnected 和share data ，为何要强调这两点呢？ 因为分布式系统并
               不一定会互联和共享数据。最简单的例如Memcache 的集群，相互之间就没有连接和共享数据，因此Memcache 集群这类分布式系统就不符合CAP 理
               论探讨的对象；而MySQL 集群就是互联和进行数据复制的，因此是CAP 理论探讨的对象。
               
           (2）第二版强调了write / read pair ，这点其实和第1 条差异点是一脉相承的。也就是说，CAP 关注的是对数据的读写操作，而不是分布式系统的所
               有功能。例如， ZooKeeper 的选举机制就不是CAP 探讨的对象。
      
       相比来说，第二版的定义更加精确。

### Consistency
   
    第一版解释：
    
    所有节点在同一时刻都能看到相同的数据。

    第二版解释：

    对某个指定的客户端来说，读操作保证能够返回最新的写操作结果
    
    第一版解释和第二版解释的主要差异点表现在以下几个方面：
    
    • 第一版从节点node 的角度描述，第二版从客户端client 的角度描述。相比来说，第二版更加符合我们观察和评估系统的方式，即站在客户端的角度来观
      察系统的行为和特征。
    • 第一版的关键词是see ，第二版的关键词是read 。第一版解释中的see ，其实并不确切，因为节点node 是拥有数据，而不是看到数据，即
      使要描述也是用have ；第二版从客户端client 的读写角度来描述一致性，定义更加精确。
    • 第一版强调同一时刻拥有相同数据（ same time + same data ），第二版并没有强调这点。这就意味着实际上对于节点来说，可能同一时刻拥有不同数
      据（ same time + different data ） ，这和我们通常理解的一致性是有差异的，

    对于系统执行事务来说，在事务执行过程中，系统其实处于一个不一致的状态，不同的节点的数据并不完全一致。因此第一版的解释“ All nodes see the 
    same data at thesame time ，， 是不严谨的，而第二版强调client 读操作能够获取最新的写结果就没有问题。因为事务在执行过程中， client 是无
    法读取到未提交的数据的， 只有等到事务提交后， client 才能读取到事务写入的数据，而如果事务失败则会进行回滚， client 也不会读取到事务中间
    写入的数据。
    
### Availability

     非故障的节点在合理的时间内返回合理的响应（ 不是错误和超时的响应〉
     
### Partition Tolerance

    第一版解释：
       尽管出现消息丢失或分区错误，但系统能够继续运行。
    
    第二版解释：
    
       当出现网络分区后，系统能够继续“ 履行职责”。
       
    第一版解释和第二版解释主要差异点表现在以下几个方面
    
    • 第一版用的是work ， 第二版用的是“nction 。work 强调“运行”，只要系统不窑机，我们都可以说系统在work：返回错误也是work,拒绝服务也是work ；
      而function 强调“发挥作用”“ 履行职责飞这点和可用性是一脉相承的。也就是说，只有返回reasonable response 才是“nction o 相比之下，第二版
      解释更加明确。
    • 第一版描述分区用的是message loss or partial failure ，第二版直接用network partitions 。相比之下，第一版是直接说原因，即message loss 
      造成了分区，但message loss 的定义有点狭隘，因为通常我们说的message loss （丢包），只是网络故障中的一种；第二版直接说现象，即发生了分区现
      象，不管是什么原因，可能是丢包，也可能是连接中断，还可能是拥塞，只要导致了网络分区，就通通算在里面。
       
       
## ACID定理

    ACID 是数据库管理系统为了保证事务的正确性而提出来的一个理论， 
    
    ACID 包含四个约束:
    
    • Atomicity （原子性）
      一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态， 就像这个
      事务从来没有执行过一样。

    • Consistency （一致性）在事务开始之前和事务结束以后，数据库的完整性没有被破坏。

    • Isolation C 隔离性）数据库允许多个并发事务同时对数据进行读写和修改的能力。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
      事务隔离分为不同级别，包括读未提交（ Readuncommitted ）、读提交（ read committed ） 、可重复读（ repeatable read ）和串行化
      （ Serializable ） 。
    • Durability （持久性）事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。
    
    可以看到， ACID 中的A ( Atomicity ）和CAP 中的 A ( Availability ）意义完全不同，而ACID中的C 和CAP 中的C 名称虽然都是一致性，但含义也
    完全不一样。ACID 中的C 是指数据库的数据完整性，CAP 中的C 是指分布式节点中的数据一致性。再结合ACID 的应用场景是数据库事务， CAP 关注的是分布式
    系统数据读写这个差异点来看，

## BASE定理

## FMEA分析方法

     FMEA 是一套分析和思考的方法，而不是某个领域的技能或工具。
     
     在软件架构设计领域， FMEA 并不是指导我们如何做架构设计，而是当我们设计出一个架构后，再使用FMEA 对这个架构进行分析，看看架构是否还存在某些
     可用性的隐患。

# 存储高可用
     
     存储高可用方案的本质都是通过将数据复制到多个存储设备，通过数据冗余的方式来实现高可用，其复杂性主要体现在如何应对复制延迟和中断导致的数据不一
     致问题。
     
     常见的高可用存储架构有主备、主从、主主、集群、分区

## 主备复制

    主备方案详细设计如下：
    
    (l) 主机存储数据，通过复制通道将数据复制到备机。

    (2）正常情况下， 客户端无论读写操作，都发送给主机，备机不对外提供任何读写服务。
    
    (3）主机故障情况下（例如， 主机岩机），客户端不会自动将请求发给备机，此时整个系统处于不可用状态，不能读写数据，但数据并没有全部丢失， 因为备
        机上有数据。
    
    (4）如果主机能够恢复（不管是人工恢复还是自动恢复〉，客户端继续访问主机，主机继续将数据复制给备机。

    (5）如果主机不能恢复（例如，机器硬盘损坏，短时间内无法恢复）， 则需要人工操作，将备机升为主机，然后让客户端访问新的主机c ep 原来的备机）；
        同时，为了继续保持主备架构，需要人工增加新的机器作为备机。
   
    (6）主机不能恢复的情况下，成功写入了主机但还没有复制到备机的数据会丢失， 需要人工进行排查和恢复， 也许有的数据就永远丢失了，业务上需要考虑如何
        应对此类风险。

    (7）如果主备间数据复制延迟，由于备机并不对外提供读写操作，因此对业务没有影响，但如果延迟较多，恰好此时主机又岩机了， 则可能丢失较多数据，因此
        对于复制延迟也不能掉以轻心。一般的做法是做复制延迟的监控措施，当延迟的数据量较大时及时报警，由人工干预处理。

    主备复制架构的优点就是简单
        
        • 对于客户端来说，不需要感知备机的存在，即使灾难恢复后，原来的备机被人工修改为主机后，对于客户端来说，只是认为主机的地址换了而己，无须知
          道是原来的备机升级为主机了。

        • 对于主机和备机来说， 双方只需要进行数据复制即可，无须进行状态判断和主备倒换这类复杂的操作。
       
    主备复制架构的缺点

        • 备机仅仅只为备份，并没有提供读写操作， 硬件成本上有浪费。
        
        • 故障后需要人工干预，无法自动恢复。
    
    通过上面的描述我们可以看到，主备架构中的“备机”主要还是起到一个备份作用，并不承担实际的业务读写操作。
    
## 主从复制

    主从复制和主备复制只有一字之差，“备”的意思是备份，“从”意思是“随从、仆从”。我们可以理解为仆从是要帮主人干活的，这里的干活就是承担“读”的操作。
    也就是说， 主机负责读写操作，从机只负责读操作，不负责写操作。
    
    主从复制方案详细解释如下：
   
    ( 1 ）主机存储数据，通过复制通道将数据复制到从机。
   
    (2 ）正常情况下，客户端写操作发送给主机，读操作可发送给主机也可以发送给从机，具体如何选择，可以根据业务的特点选择。可以随机读，可以轮询读，可以
         只读主机， 等等。
   
    (3 ）主机故障情况下（例如，主机岩机），客户端无法进行写操作，但可以将读操作发送给从机，从机继续响应读操作，此时和写操作相关的业务不可用（例如，
         论坛发中的，但和读操作相关的操作不受影响（例如，论坛看1μ占） 。
        
    (4 ）如果主机能够恢复（不管是人工恢复还是自动恢复〉，客户端继续将写操作请求发送给主机，主机继续将数据复制给备机。
   
    (5 ）如果主机不能恢复（例如，机器硬盘损坏，短时间内无法恢复）， 则需要人工操作，将备机升为主机，然后让客户端访问新的主机（即原来的备机）；同时，
         为了继续保持主备架构，需要人工增加新的机器作为备机。
   
    (6 ）主机不能恢复的情况下，成功写入了主机但还没有复制到备机的数据会丢失，需要人工进行排查和恢复，也许有的数据就永远丢失了，业务上需要考虑如何应
         对此类风险。
   
    (7 ）如果主从间数据复制延迟，则会出现主从读取的数据不一致的问题。例如，用户刚发了一个新帖，此时数据还没有从主机复制到从机，用户刷新了页面，这个
         读操作请求发送到了从机，从机上并没有用户最新发表的帖子，这时用户就看不到刚才发的帖子了，会以为帖子丢了；如果再刷新一次，可能又展现出来了，
         因为第二次刷新的读请求发给了主机。

    (8 ）如果主从间延迟较多，恰好此时主机又看机了，则可能丢失较多数据，因此对于复制延迟也不能掉以轻心。一般的做法是做复制延迟的监控措施，当延迟的数
        据量较大时及时报警，由人工干预处理。
    
    
    主从复制架构的优点：
    
        • 主从复制在主机故障时，读操作相关的业务不受影响；
        
        • 主从复制架构的从机提供读操作，发挥了硬件的性能；
        
        • 主从复制要比主备复制复杂更多，主要体现在客户端需要感知主从关系，并将不同的操作发给不同的机器进行处理。
    
    主从复制的缺点：
    
         故障时需要人工干预
         
     一般情况下，写少读多的业务使用主从复制的存储架构比较多。例如，论坛、BBS 、新闻网站这类业务，此类业务的读操作数量是写操作数量的10 倍甚至
     100倍以上。     
    
## 主主复制

     主主复制指的是两台机器都是主机，互相将数据复制给对方，客户端可以任意挑选其中一台机器进行读写操作。
     
     主主复制架构的详细解释如下：
     
     （l） 两台主机都存储数据，通过复制通道将数据复制到另外一台主机。

     （2） 正常情况下， 客户端可以将读写操作发送给任意一台主机。

      (3） 一台主机故障情况下，例如主机A 岩机，客户端只需要将读写操作发送给主机B 即可，反之亦然。
      
      (4） 如果故障的主机A 能够恢复（不管是人工恢复还是自动恢复）， 则客户端继续访问两台主机，两台主机间继续互相复制对方数据。
      
      (5） 如果故障的主机A 不能恢复（ 例如，机器硬盘损坏， 短时间内无法恢复） ，则需要人工操作，增加一台新的机器作为主机。
     
      (6） 原有故障主机A 不能恢复的情况下，成功写入了原有故障主机但还没有复制到正常主机B 的数据会丢失，需要人工进行排查和恢复， 也许有的数据就
          永远丢失了，业务上需要考虑如何应对此类风险。

      (7 ）如果两台主机间复制延迟，则可能出现客户端刚写入了数据到主机A，然后到主机B去读取，此时读取不到刚刚写入的数据。
      
      相比主备倒换架构，主主复制架构具有如下特点：
         
         •  两台都是主机， 不存在倒换的概念；
         
         •  客户端无须区分不同角色的主机，随便将读写操作发送给哪台主机都可以。      
      
      从上面的描述来看，主主复制架构从总体上来看要简单很多，无须状态信息传递，也无须状态决策和状态切换。然而事实上主主复制架构也并不简单，而是有
      其独特的复杂性，具体表现在：如果采取主主复制架构，必须保证数据能够双向复制，而很多数据是不能双向复制的。

      例如：
         
         • 用户注册后生成的用户ID ，如果按照数字增长，那就不能双向复制，否则就会出现X用户在主机A 注册，分配的用户ID 是100 ，同时Y 用户在主机B
           注册，分配的用户ID也是100 ，这就出现了冲突。
           
         • 库存不能双向复制。例如， 一件商品库存100 件，主机A 上减了l 件变成99 ， 主机B上喊了2 件变成饨，然后主机A 将库存99 复制到主机B ，主机B
           原有的库存98 被覆盖，变成了99 ，而实际上此时真正的库存是97 。类似的还有余额数据。
           
       因此，主主复制架构对数据的设计有严格的要求， 一般适合于那些临时性、可丢失、可覆盖的数据场景。例如， 用户登录产生的session 数据（可以重新登
       录生成〉，用户行为的日志数据（ 可以丢失），论坛的草稿数据（可以丢失）等。           
      
     
## 主备倒换与主从倒换

    主备复制和主从复制方案存在两个共性的问题：
    
     (1 ）主机故障后，无法进行写操作。
     (2 ）如果主机无法恢复，需要人工指定新的主机角色。

     主备倒换和主从倒换方案就是为了解决上述两个问题而产生的。简单来说，这两个方案就是在原有方案的基础上增加“倒换”功能， 即系统自动决定主机角色， 并
     完成角色切换。由于主备倒换和主从倒换在倒换的设计上没有差别，

     要实现一个完善的倒换方案，必须考虑如下几个关键的设计点：
     
     (1 ）主备间状态判断。主要包括两方面：状态传递的渠道和状态检测的内容。
     
         • 状态传递的渠道。是相互间互相连接，还是第三方仲裁？
         
         • 状态检测的内容。例如，机器是否掉电，进程是否存在，响应是否缓慢，等等。

     (2）倒换决策。

         主要包括几方面： 倒换时机、倒换策略、自动程度
          
         • 倒换时机

           什么情况下备机应该升级为主机？ 是机器掉电后备机才升级，还是主机上的进程不存在就升级，还是主机响应时间超过2s 就升级，还是3 分钟内主机
           连续重启3 次就升级，等等。

         • 倒换策略

           原来的主机故障恢复后， 要再次倒换，确保原来的主机继续做主机，还是原来的主机故障恢复后自动成为新的备机？
           
         • 自动程度

           倒换是完全自动的，还是半自动的？例如，系统判断当前需要倒换，但需要人工做最终的确认操作（例如，单击一下“倒换”按钮） 。
           
     (3）数据冲突解决。

         当原有故障的主机恢复后，新旧主机之间可能存在数据冲突。例如，用户在旧主机上新增了一条ID 为100 的数据，这个数据还没有复制到旧的备机，此时
         发生了倒换，旧的备机升级为新的主机，用户又在新的主机上新增了一条ID 为100 的数据，当旧的故障主机恢复后，这两条ID 都为100 的数据，应该怎
         么处理？           


     根据状态传递渠道的不同，常见的主备倒换架构有三种形式：互连式、中介式和模拟式。
     
     •  互连式
        
        顾名思义，互连式就是指主备机直接建立状态传递的渠道，
        
        在主备复制的架构基础上，主机和备机多了一个“状态传递”的通道，这个通道就是用来传递状态信息的。这个通道的具体实现可以有很多方式：
        
           (1）可以是网络连接（例如，各开一个端口），也可以是非网络连接（用串口线连接〉。
           
           (2〕可以是主机发送状态给备机，也可以是备机到主机来获取状态信息。
           
           (3）可以和数据复制通道共用，也可以独立一条通道。

           (4）状态传递通道可以是一条，也可以是多条，还可以是不同类型的通道混合（例如，网络＋串口〉。
          
        为了充分利用主备自动倒换方案能够自动决定主机这个优势，客户端这里也会有一些相应的改变，常见的方式有如下两种：

           • 为了倒换后不影响客户端的访问，主机和备机之间共享一个对客户端来说唯一的地址。
             例如，虚拟IP，主机需要绑定这个虚拟的IP o

           • 客户端同时记录主备机的地址， 哪个能访问就访问哪个； 备机虽然能收到客户端的操作请求，但是会直接拒绝，拒绝的原因就是“备机不对外提
             供服务”。  
        
        互连式主备倒换主要的缺点：
        
            如果状态传递的通道本身有故障（例如，网线被人不小心踢掉了），那么备机也会认为主机故障了从而将自己升级为主机，而此时主机并没有故障， 
            最终就可能出现两个主机。虽然可以通过增加多个通道来增强状态传递的可靠性，但这样做只是降低了通道故障概率而己，不能从根本上解决这个缺
            点。而且通道越多，后续的状态决策会更加复杂。因为对备机来说，可能从不同的通道收到了不同甚至矛盾的状态信息。
        
     • 中介式
        
            中介式指的是在主备两者之外引入第三方中介，主备机之间不直接连接，而都去连接中介，并且通过中介来传递状态信息
            
            主备倒换中的中介就可以用ZooKeeper 来做状态同步，，主要用来解决分布式应用中经常遇到的一些数据管理问题。例如，统一命名服务、状态同
            步服务、集群管理、分布式应用配置项的管理，

            中介式架构优点
            
     • 模拟式

            模拟式指主备机之间并不传递任何状态数据，而是备机模拟成一个客户端，向主机发起模拟的读写操作，根据读写操作的响应情况来判断主机的状态。
            
            对比一下互连式倒换架构，我们可以看到，主备机之间只有数据复制通道，而没有状态传递通道， 备机通过模拟的读写操作来探测主机的状态，然后根
            据读写操作的响应情况来进行状态决策。
            
            模拟式倒换与互连式倒换相比，具有如下优缺点：
            
            •  实现更加简单， 因为省去了状态传递通道的建立和管理工作
            •  模拟式读写操作获取的状态信息只有响应信息（例如， HTTP 404 ， 超时、响应时间超过3s 等〉，没有互连式那样多样（除了响应信息， 
               还可以包含CPU 负载、I/O 负载、吞吐量、响应时间等），基于有限的状态来做状态决策，可能出现偏差。

# 数据集群
 
      根据集群中机器承担的不同角色来划分， 集群可以分为两类：数据集中集群、数据分散集群。
      
      数据集中集群架构中，客户端只能将数据写到主机；数据分散集群架构中，客户端可以向任意服务器中读写数据。正是因为这个关键的差异，决定了两种集群的
      应用场景不同。一般来说，数据集中式集群适合数据量不大，集群机器数量不多的场景。例如， ZooKeeper 集群，一般推荐5 台机器左右，数据量是单台服务
      器就能够支撑；而数据分散式集群，由于其良好的可伸缩性，适合业务数据量巨大， 集群机器数量庞大的业务场景。例如， Hadoop 集群、HBase 集群，大规
      模的集群可以达到上百台甚至上千台服务器。

## 数据集中集群

     数据集中集群与主备、主从这类架构相似，我们也可以称数据集中集群为l 主多备或l 主多从。无论l 主l 从、I 主l 备，还是l 主多备、l 主多从，数据都
     只能往主机中写，而读操作可以参考主备、主从架构进行灵活多变。
     
     目前开源的数据集中式集群以Zookeeper 为典型，
     
     数据集中集群复杂度:
     
     • 主机如何将数据复制给备机
     
           主备和主从架构中，只有一条复制通道，而数据集中集群架构中，存在多条复制通道。多条复制通道首先会增大主机复制的压力，某些场景下我们需要
           考虑如何降低主机复制压力，或者降低主机复制给正常读写带来的压力。其次，多条复制通道可能会导致多个备机之间数据不一致，某些场景下我们需
           要对备机之间的数据一致性进行检查和修正，例如， ZooKeeper 在重新选举Leader 后会进入恢复阶段。

     • 备机如何检测主机状态

           主备和主从架构中，只有一台备机需要进行主机状态判断。数据集中集群架构中，多台备机都需要对主机状态进行判断，而不同的备机判断的结果可能是
           不同的，如何处理不同备机对主机状态的不同判断，是一个复杂的问题。

     • 主机故障后，如何决定新的主机

           主从架构中，如果主机故障，将备机升级为主机即可；而数据集中的集群架构中，有多台备机都可以升级为主机，但实际上只能允许一台备机升级为
           主机，那么究竟选择哪一台备机作为新的主机，备机之间如何协调，这也是一个复杂的问题。
           
## 数据分布集群           
           
     数据分散集群指多个服务器组成一个集群，每台服务器都会负责存储一部分数据：同时，为了提升硬件利用率，每台服务器又会备份一部分数据。      
     
     Hadoop 的实现就是独立的服务器负责数据分区的分配
     
     数据分布集群复杂度在于如何将数据分配到不同的服务器上,算法需要考虑如下设计点：
     
     • 均衡性
           
           算法需要保证服务器上的数据分区基本是均衡的，不能存在某台服务器上的分区数量是另外一台服务器的几倍的情况。
     
     • 容错性
     
           当出现部分服务器故障时， 算法需要将原来分配给故障服务器的数据分区分配给其他服务器。
     
     • 可伸缩性
           
           当集群容量不够，扩充新的服务器后，算法能够自动将部分数据分区迁移到新服务器，并保证扩容后所有服务器的均衡性。
     
     数据分散集群和数据集中集群的不同点：在于数据分散集群中的每台服务器都可以处理读写请求，因此不存在数据集中集群中负责写的主机那样的角色。但在数
     据分区集群中，必须有一个角色来负责执行数据分配算法，这个角色可以是独立的一台服务器，也可以是集群自己选举出的一台服务器。如果是集群服务器选举
     出来一台机器承担数据分区分配的职责，则这台服务器一般也会叫作主机，但我们需要知道这里的“主机”和数据集中集群中的“主机”， 其职责是有差异的。


# 视频

  * [Tomcat+Memcached Redis集群构建高可用解决方案(上)](https://www.bilibili.com/video/av70448618?from=search&seid=87210491669533119)
  * [Tomcat+Memcached Redis集群构建高可用解决方案(下)](https://www.bilibili.com/video/av70430594/?spm_id_from=333.788.videocard.0)
  * [大型高并发与高可用缓存架构实战 (上)](https://www.bilibili.com/video/av48758838?from=search&seid=10562626782325115402)
  * [java 深入剖析Redis高可用集群构架原理及高并发锁实战](https://www.bilibili.com/video/av54159076?from=search&seid=1627730393722049451)
  
  
  
           
# 有用的参考

* 从零开始学架构：照着做，你也能成为架构师.pdf
* 从零开始学架构--系列文集（李运华）.pdf
* 大型网站技术核心原理与案例分析.pdf
* 软件架构设计：大型网站技术架构与业务架构融合之道.pdf
* 亿级流量网站架构核心技术+跟开涛学搭建高可用高并发系统.pdf
* 高可用架构.pdf
* 可伸缩架构-面向增长应用的高可用.pdf


 * [究竟啥才是互联网架构“高可用](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959728&idx=1&sn=933227840ec8cdc35d3a33ae3fe97ec5&chksm=bd2d046c8a5a8d7a13551124af36bedf68f7a6e31f6f32828678d2adb108b86b7e08c678f22f&scene=21#wechat_redirect)
 
 * [高可用架构详解](https://blog.csdn.net/wuxing26jiayou/article/details/54584906)
