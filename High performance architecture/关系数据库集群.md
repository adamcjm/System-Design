
**高性能数据库集群的第一种方式是“读写分离”，其本质是将访问压力分散到集群中的多个节点，但是没有分散存储压力；第二种方式是“分库分表飞既可以分散访问压力，又可以分散存储压力。读写分离需要将读／写操作区分开来，然后访问不同的数据库服务器； 分库分表需要根据不同的数据访问不同的数据库服务器，两者本质上都是一种分配机制，即将不同的SQL 语句发送到不同的数据库服务器**

* [关系数据库的缺点](#关系数据库的缺点)

* [读写分离](#读写分离)
* [分库分表](#分库分表)
  * [业务分库](#业务分库)
  * [分表](#分表)

* [关系数据库高性能存储的实现方式](#关系数据库高性能存储的实现方式)
  * 程序代码封装
  * 中间件封装

# 关系数据库的优点




## 读写分离

  读写分离的基本原理是将数据库读写操作分散到不同的节点上,读写分离的基本实现如下：
  
      (1）数据库服务器搭建主从集群， 一主一从、一主多从都可以。
      
      (2）数据库主机负责读写操作，从机只负责读操作。
      
      (3）数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。
      
      (4）业务服务器将写操作发给数据库主机，将读操作发给数据库从机。

  **读写分离的复杂度：**
  
     读写分离的实现逻辑并不复杂，读写分离实现时只要识别SQL 操作是读操作还是写操作即可，通过简单地判断SELECT 、UPDATE 、时SERT 、DELETE 几个
     关键字就可以实现，但在实际应用过程中需要应对复制延迟带来的复杂性。
     
     正确解决读写分离复制延迟的方法：
     
         (1）写操作后的读操作指定发给数据库主服务器。
         
             例如，注册账号完成后， 登录时读取账号的读操作也发给数据库主服务器。这种方式和业务强绑定，对业务的侵入和影响较大，如果哪个新来的程序
             员不知道这样写代码，就会导致一个bug 。
         
         (2）读从机失败后再读一次主机。
         
             这就是通常所说的“二次读取”，二次读取和业务无绑定，只需要对底层数据库访问的API，进行封装即可， 实现代价较小， 不足之处在于如果有很多二
             次读取，将大大增加主机的读操作压力。例如， 黑客暴力破解账号， 会导致大量的二次读取操作，主机可能顶不住读操作的压力从而崩愤。
         
         (3）关键业务读写操作全部指向主机，非关键业务采用读写分离。
         
             例如，对于一个用户管理系统来说，注册＋登录的业务读写操作全部访问主机， 用户的介绍、爱好、等级等业务，可以采用读写分离，因为即使用户改
             了自己的自我介绍，在查询时却看到了自我介绍还是旧的，业务影响与不能登录相比就小很多，还可以忍受。



## 分库分表

  **分库分表复杂度**
  
    而分库分表的实现除了要判断操作类型，还要判断SQL 中的具体需要操作的表、操作函数（例如， count 函数〉、order by 、group by 操作等，然后根据不
    同的操作进行不同的处理。例如， order by 操作需要先从多个库查询各个库的数据， 然后重新执行order by 才能得到最终的结果。相比来说，分库分表的实
    现要复杂得多。

## 业务分库

   业务分库指的是按照业务模块将数据分散到不同的数据库服务器
   
   **业务分库的缺点**
   
     【join 操作问题】
     
         业务分库后，原本在同一个数据库中的表分散到不同数据库中，导致无法使用SQL 的join查询。例如： “查询购买了化妆品的用户中女性用户的列表”这个
         功能，虽然订单数据中有用户的id 信息，但是用户的性别数据在用户数据库中，如果在同一个库中，则简单的jo in 查询就能完成，但现在数据分散在两个
         不同的数据库中，无法做join 查询。只能采取先从订单数据库中查询购买了化妆品的用户id 列表，然后到用户数据库中查询这批用户id 中的女性用户列
         表，这样实现就比简单的j oin 查询复杂多了。

     【事务问题】
         
         原本在同一个数据库中不同的表可以在同一个事务中修改，业务分库后，表分散到不同的数据库中，无法通过事务统一修改。虽然数据库厂商提供了一些分布
         式事务的解决方案（例如，MySQL 的XA ），但性能实在太低，与高性能存储的目标是相违背的。例如，用户下订单的时候需要扣减商品库存，如果订单数据
         和商品数据在同一个数据库中，我们可以使用事务来保证扣减商品库存和生成订单的操作要么都成功要么都失败，但分库后就无法使用数据库事务了，需要业
         务程序自己来模拟实现事务的功能。例如，先扣减商品库存，扣减成功后生成订单，如果因为订单数据库异常导致生成订单失败，业务程序又需要将商品库
         存加上：而如果因为业务程序自己异常导致生成订单失败，则商品库存就无法恢复了，需要人工通过日志等方式来于工修复库存异常。
         
     【成本问题】

         业务分库同时也带来了成本的代价，本来1 台服务器搞定的事情，现在要3 台，如果考虑备份，那就是2 台变成了6 台。基于上述原因，对于初创业务，并
         不建议一开始就这样拆分，主要有几个原因：
         
         (1）初创业务存在很大的不确定性，业务不一定能发展起来，业务开始的时候并没有真正的存储和访问压力，业务分库并不能为业务带来价值。

         (2）业务分库后，表之间的join 查询、数据库事务无法简单实现了。

         (3 ）业务分库后，因为不同的数据要读写不同的数据库，代码中需要增加根据数据类型映射到不同数据库的逻辑，增加了工作量。而业务初创期间最重要的
              是快速实现、快速验证，业务分库会拖慢业务节奏。         

## 分表

  * 垂直分表
  
    从上往下切就是垂直切分，因为刀的运行轨迹与蛋糕是垂直的，这样可以把蛋糕切成高度相等（面积可以相等也可以不相等）的两部分，对应到表的切分就是
    表记录数相同,包含不同的列。
    
  **垂直分表的复杂度**
    
       主要体现在表操作的数量要增加
       
       假设我们是一个婚恋网站，用户在筛选其他用户的时候， 主要是用age 和sex 两个字段进行查询，而nickname 和description 两个宇段主要用于展示， 
       一般不会在业务查询中用到。description 本身又比较长，因此我们可以将这两个字段独立到另外一张表中，
    
    
  * 水平分表
  
    从左往右切就是水平切分，因为刀的运行轨迹与蛋糕是平行的，这样可以把蛋糕切成面积相等（高度可以相等也可以不相等）的两部分，对应到表的切分就是表的
    列相同但包含不同的行数据。

     **水平分表的复杂度**

          水平分表适合表行数特别大的表，如果单表行数超过5000 万就必须进行分表，这个数字可以作为参考，但并不是绝对标准，关键还是要看表的访问性能。
          水平分表相比垂直分表，会引入更多的复杂性。
          
         【路由】
                水平分表后，某条数据具体属于哪个切分后的子表，需要增加路由算法进行计算，这个算法会引入一定的复杂性。
                
               • 范围路由
               
                    选取有序的数据列（例如，整型、时间戳等〉作为路由的条件，不同分段分散到不同的数据库表中。以最常见的用户ID 为例，路由算法可以
                    按照1000000 的范围大小进行分段， l ～ 999999放到数据库l 的表中， 1000000 ～ 1999999 放到数据库2 的表中，以此类推。

               • Hash 路由
               
                   选取某个列（或者某几个列组合也可以〉的值进行Hash 运算，然后根据Hash 结果分散到不同的数据库表中
                   
               • 配置路由
               
                   配置路由就是路由表，用一张独立的表来记录路由信息。
               
         【j o i n 操作】
               水平分表后，数据分散在多个表中，如果需要与其他表进行j oi n 查询，需要在业务代码或数据库中间件中进行多次j o in 查询，然后将结果
               合井。
               
         【co un t（）操作】
         
               水平分表后，虽然物理上数据分散到多个表中，但某些业务逻辑上还是会将这些表当作一个表来处理。例如，获取记录总数用于分页或展示， 水平
               分表前用一个count（）就能完成的操作，在分表后就没那么简单了。常见的处理方式有如下两种。
               
                   • count（）相加
                        具体做法是在业务代码或数据库中间件中对每个表进行co u nt （）操作，然后将结果相加。这种方式实现简单，缺点就是性能比较低。
                        例如，水平分表后切分为20 张表，则要进行2 0 次count(*)操作，如果串行的话， 则可能需要几秒钟才能得到结果。
                   • 记录数表
                        具体做法是新建一张表，假如表名为“记录数表飞包含tabl e_na me 、row_co unt 两个字段，每次插入或删除子表数据成功后，都更
                        新“记录数表”。
         
         【order b y 操作】
         
               水平分表后， 数据分散到多个子表中，排序操作无法在数据库中完成，只能由业务代码或数据库中间件分别查询每个子表中的数据，然后汇总进行
               排序。               
                        
                        
# 关系数据库的缺点

     (1）关系数据库存储的是行记录，无法存储数据结构。以微博的关注为例，“我关注的人”是一个用户ID 列表，使用关系数据库存储只能将列表拆成多行，然后
         再查询出来组装，无法直接存储一个列表。

     (2）关系数据库的schema 扩展很不方便。关系数据库的表结构schema 是强约束，操作不存在的列会报错，业务变化时扩充列也比较麻烦，需要执行DDL 
         ( data definition l anguage ，如CREATE 、ALTER、DROP 等）语句修改，而且修改时可能会长时间锁表（例如， MySQL 可能将表锁住l 个小时）。
          
     (3）关系数据库在大数据场景下I/O 较高,例如，对一些大量数据的表进行统计之类的运算，关系数据库的I/O 会很高，因为即使只针对其中某一列进行运算，
         关系数据库也会将整行数据读取。

     (4）关系数据库的全文搜索功能比较弱。关系数据库的全文搜索只能使用like 进行整表扫描匹配，性能非常低，在互联网这种搜索复杂的场景下无法满足
         业务要求。

# 关系数据库高性能存储的实现方式

**读写分离需要将读／写操作区分开来，然后访问不同的数据库服务器； 分库分表需要根据不同的数据访问不同的数据库服务器，两者本质上都是一种分配机制，即将不同的SQL 语句发送到不同的数据库服务器**

## 程序代码封装

   **程序代码封装指在代码中抽象一个数据访问层来实现读写分离、分库分表**

   **程序代码封装的方式具备如下几个特点：**
   
      • 实现简单， 而且可以根据业务做较多定制化的功能。
   
      • 每个编程语言都需要自己实现一次， 无法通用， 如果一个业务包含多个编程语言写的多个子系统，则重复开发的工作量比较大。
   
      • 故障情况下，如果主从发生切换， 则可能需要所有系统都修改配置井重启。


  **目前开源的实现方案中**
  
   淘宝的TDDL ( Taobao Di s tributed Data L ayer ， 外号： 头都大了）是比较有名的。它是一个通用数据访问层，所有功能封装
   在j a r 包中供业务代码调用。其基本原理是一个基于集中式配置的jdbc datasource 实现，具有主备、读写分离、动态数据库配置等功能

## 中间件封装

   **中间件封装指的是独立一套系统出来，实现读写分离和分库分表操作**，中间件对业务服务器提供SQL 兼容的协议，对于业务服务器来说，访问中间件和访问数
     据库没有区别， 事实上在业务服务器看来，中间件就是一个数据库服务器。
   
   **由于数据库中间件的复杂度要比程序代码封装高出一个数量级， 一般情况下建议采用程序语言封装的方式，或者使用成熟的开源数据库中间件**
   
   **数据库中间件的方式具备如下特点**：
   
     • 能够支持多种编程语言，因为数据库中间件对业务服务器提供的是标准SQL 接口。
   
     • 数据库中间件要支持完整的SQL 语法和数据库服务器的协议（例如， MySQL 客户端和服务器的连接协议），这是一个很复杂的事情，而且细节特别多，很容易
       出现bug
     
     • 数据库中间件自己不执行真正的读写操作，但所有的数据库操作请求都要经过中间件，中间件的性能要求也很高。

     • 数据库主从切换对业务服务器无感知， 数据库中间件可以探测数据库服务器的主从状态。例如，向某个测试表写入－ 条数据，成功的就是主机，失败的就
       是从机。
   
   
   **目前开源的实现方案中**   
   
       MySQL 官方先是提供了mysql-proxy，但mysql-proxy一直没有正式GA ，现在MySQL 官方推荐MySQL Router 。MySQL Router 的主要功能有读写
       分离、故障自动切换、负载均衡、连接池等，
   
